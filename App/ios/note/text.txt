



import UIKit

class ViewController: UIViewController {
    @IBOutlet weak var tv: UITextView!

    override func viewDidLoad() {
        super.viewDidLoad()
        let url = Bundle.main.url(forResource: "test", withExtension: "rtf")!
        let opts = [NSDocumentTypeDocumentAttribute:NSRTFTextDocumentType]
        var d : NSDictionary? = nil
        let s = try! NSAttributedString(url: url, options: opts, documentAttributes: &d)
        self.tv.attributedText = s
    }


}





import UIKit
import Swift

class ViewController: UIViewController {
    @IBOutlet weak var lab: UILabel!

    override func viewDidLoad() {
        super.viewDidLoad()

//        let mas = NSMutableAttributedString(string: "Buy beer", attributes: [
//            NSUnderlineStyleAttributeName: NSUnderlineStyle.StyleNone.rawValue
//            ])
        
        let mas = NSMutableAttributedString(string: "Buy beer")

        // this didn't work in iOS 8 until it was fixed in iOS 8.3
//        mas.addAttributes([
//            NSUnderlineStyleAttributeName: NSUnderlineStyle.StyleSingle.rawValue
//            ], range: NSMakeRange(4, mas.length-4))
    
        // showing that it is necessary to use freaking bitwise-or to form this bitmask still
        let under = NSUnderlineStyle.styleThick.rawValue | NSUnderlineStyle.patternDash.rawValue
        mas.addAttributes([
            NSUnderlineStyleAttributeName: under
            ], range: NSMakeRange(4, mas.length-4))

        
        self.lab.attributedText = mas
    
    }



}












import UIKit
import ImageIO

extension CGRect {
    init(_ x:CGFloat, _ y:CGFloat, _ w:CGFloat, _ h:CGFloat) {
        self.init(x:x, y:y, width:w, height:h)
    }
}
extension CGSize {
    init(_ width:CGFloat, _ height:CGFloat) {
        self.init(width:width, height:height)
    }
}
extension CGPoint {
    init(_ x:CGFloat, _ y:CGFloat) {
        self.init(x:x, y:y)
    }
}
extension CGVector {
    init (_ dx:CGFloat, _ dy:CGFloat) {
        self.init(dx:dx, dy:dy)
    }
}



func lend<T> (closure:(T)->()) -> T where T:NSObject {
    let orig = T()
    closure(orig)
    return orig
}

class ViewController : UIViewController {
    @IBOutlet var tv : UITextView!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        let s = "Onions\t$2.34\nPeppers\t$15.2\n"
        let mas = NSMutableAttributedString(string:s, attributes:[
            NSFontAttributeName:UIFont(name:"GillSans", size:15)!,
            NSParagraphStyleAttributeName:lend {
                (p:NSMutableParagraphStyle) in
                let terms = NSTextTab.columnTerminators(for:Locale.current)
                let tab = NSTextTab(textAlignment:.right, location:170, options:[NSTabColumnTerminatorsAttributeName:terms])
                var which : Int { return 2 }
                switch which {
                case 1:
                    p.tabStops = [tab]
                case 2:
                    for oldTab in p.tabStops {
                        p.removeTabStop(oldTab)
                    }
                    p.addTabStop(tab)
                default: break
                }
                
                p.firstLineHeadIndent = 20
            }
            ])
        self.tv.attributedText = mas
        
        // return;
        
        let onions = self.thumbnailOfImage(name:"onion", extension:"jpg")
        let peppers = self.thumbnailOfImage(name:"peppers", extension:"jpg")
        
        let onionatt = NSTextAttachment()
        onionatt.image = onions
        onionatt.bounds = CGRect(0,-5,onions.size.width,onions.size.height)
        let onionattchar = NSAttributedString(attachment:onionatt)
        
        let pepperatt = NSTextAttachment()
        pepperatt.image = peppers
        pepperatt.bounds = CGRect(0,-1,peppers.size.width,peppers.size.height)
        let pepperattchar = NSAttributedString(attachment:pepperatt)
        
        let r = (mas.string as NSString).range(of:"Onions")
        mas.insert(onionattchar, at:(r.location + r.length))
        let r2 = (mas.string as NSString).range(of:"Peppers")
        mas.insert(pepperattchar, at:(r2.location + r2.length))
        
        mas.append(NSAttributedString(string: "\n\n", attributes:nil))
        mas.append(NSAttributedString(string: "LINK", attributes: [
            NSLinkAttributeName : URL(string: "https://www.apple.com")!,
            NSForegroundColorAttributeName : UIColor.orange, // not working
            ]))
        mas.append(NSAttributedString(string: "\n\n", attributes:nil))
        mas.append(NSAttributedString(string: "(805)-123-4567", attributes: nil))
        mas.append(NSAttributedString(string: "\n\n", attributes:nil))
        mas.append(NSAttributedString(string: "123 Main Street, Anytown, CA 91234", attributes: nil))
        mas.append(NSAttributedString(string: "\n\n", attributes:nil))
        mas.append(NSAttributedString(string: "tomorrow at 4 PM", attributes: nil))

        
        self.tv.attributedText = mas
        
        // this works but it applies to all links
        //self.tv.linkTextAttributes = [NSForegroundColorAttributeName : UIColor.orange]
        
//        print(NSAttachmentCharacter)
//        print(0xFFFC)
        
        self.tv.isSelectable = true
        self.tv.isEditable = false
        self.tv.delegate = self
    }
    
    func thumbnailOfImage(name:String, extension ext: String) -> UIImage {
        let url = Bundle.main.url(forResource:name,
                withExtension:ext)!
        let src = CGImageSourceCreateWithURL(url as CFURL, nil)!
        let scale = UIScreen.main.scale
        let w : CGFloat = 20 * scale
        let d : NSDictionary = [
            kCGImageSourceShouldAllowFloat : true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceCreateThumbnailFromImageAlways: true,
            kCGImageSourceThumbnailMaxPixelSize: w
        ]
        let imref =
        CGImageSourceCreateThumbnailAtIndex(src, 0, d)!
        let im = UIImage(cgImage:imref, scale:scale, orientation:.up)
        return im
    }
    
}

@available(iOS 10.0, *)
extension ViewController : UITextViewDelegate {
    func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction:UITextItemInteraction) -> Bool {
        print(interaction.rawValue)
        return true
    }
    
    func textView(_ textView: UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: NSRange, interaction:UITextItemInteraction) -> Bool {
        print(URL)
        print((textView.text as NSString).substring(with:characterRange))
        print(interaction.rawValue)
        return true
    }
}









import UIKit

class ViewController: UIViewController {
    
    @IBOutlet var lab : UILabel!
    
    @IBAction func doUpdateLabel(_ sender: Any?) {
        let mas = self.lab.attributedText!.mutableCopy() as! NSMutableAttributedString
        let r = (mas.string as NSString).range(of:"^0")
        if r.length > 0 {
            mas.addAttribute("HERE", value: 1, range: r)
            mas.replaceCharacters(in:r, with: Date().description)
        } else {
            mas.enumerateAttribute("HERE", in: NSMakeRange(0, mas.length)) {
                value, r, stop in
                if let value = value as? Int, value == 1 {
                    mas.replaceCharacters(in:r, with: Date().description)
                    stop.pointee = true
                }
            }
        }
        self.lab.attributedText = mas
    }


}












import UIKit

func lend<T> (closure:(T)->()) -> T where T:NSObject {
    let orig = T()
    closure(orig)
    return orig
}

extension CGRect {
    init(_ x:CGFloat, _ y:CGFloat, _ w:CGFloat, _ h:CGFloat) {
        self.init(x:x, y:y, width:w, height:h)
    }
}
extension CGSize {
    init(_ width:CGFloat, _ height:CGFloat) {
        self.init(width:width, height:height)
    }
}
extension CGPoint {
    init(_ x:CGFloat, _ y:CGFloat) {
        self.init(x:x, y:y)
    }
}
extension CGVector {
    init (_ dx:CGFloat, _ dy:CGFloat) {
        self.init(dx:dx, dy:dy)
    }
}



class ViewController : UIViewController {
    @IBOutlet var drawer : StringDrawer!
    @IBOutlet var iv : UIImageView!
    lazy var content = self.makeAttributedString()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        // draw into 280 x 250 image
        let rect = CGRect(0,0,280,250)
        let r = UIGraphicsImageRenderer(size:rect.size)
        let im = r.image { ctx in 
            let con = ctx.cgContext
            UIColor.white.setFill()
            con.fill(rect)
            content.draw(in:rect) // draw attributed string
        }

        
//        UIGraphicsBeginImageContextWithOptions(rect.size, true, 0)
//        UIColor.white().setFill()
//        UIGraphicsGetCurrentContext()!.fill(rect)
//        content.draw(in:rect) // draw attributed string
//        let im = UIGraphicsGetImageFromCurrentImageContext()!
//        UIGraphicsEndImageContext()
        
        // display the image
        
        self.iv.image = im
        
        // another way: draw the string in a view's drawRect:
        
        self.drawer.attributedText = content
        
    }
    
    func makeAttributedString() -> NSAttributedString {
        var content : NSMutableAttributedString!
        var content2 : NSMutableAttributedString!
        
        let s1 = "The Gettysburg Address, as delivered on a certain occasion " +
        "(namely Thursday, November 19, 1863) by A. Lincoln"
        content = NSMutableAttributedString(string:s1, attributes:[
            NSFontAttributeName: UIFont(name:"Arial-BoldMT", size:15)!,
            NSForegroundColorAttributeName: UIColor(red:0.251, green:0.000, blue:0.502, alpha:1)]
        )

        let r = (s1 as NSString).range(of:"Gettysburg Address")
        content.addAttributes([
            NSStrokeColorAttributeName: UIColor.red,
            NSStrokeWidthAttributeName: -2.0
        ], range: r)
        
        content.addAttribute(NSParagraphStyleAttributeName,
            value:lend(){
            (para:NSMutableParagraphStyle) in
            para.headIndent = 10
            para.firstLineHeadIndent = 10
            para.tailIndent = -10
            para.lineBreakMode = .byWordWrapping
            para.alignment = .center
            para.paragraphSpacing = 15
        }, range:NSMakeRange(0,1))
        
        var s2 = "Fourscore and seven years ago, our fathers brought forth " +
            "upon this continent a new nation, conceived in liberty and dedicated "
        s2 = s2 + "to the proposition that all men are created equal."
        content2 = NSMutableAttributedString(string:s2, attributes: [
            NSFontAttributeName: UIFont(name:"HoeflerText-Black", size:16)!
            ])
        content2.addAttributes([
            NSFontAttributeName: UIFont(name:"HoeflerText-Black", size:24)!,
            NSExpansionAttributeName: 0.3,
            NSKernAttributeName: -4 // negative kerning bug fixed in iOS 8
            ], range:NSMakeRange(0,1))
        
        content2.addAttribute(NSParagraphStyleAttributeName,
            value:lend(){
            (para2 : NSMutableParagraphStyle) in
            para2.headIndent = 10
            para2.firstLineHeadIndent = 10
            para2.tailIndent = -10
            para2.lineBreakMode = .byWordWrapping
            para2.alignment = .justified
            para2.lineHeightMultiple = 1.2
            para2.hyphenationFactor = 1.0
        }, range:NSMakeRange(0,1))
        
        let end = content.length
        content.replaceCharacters(in:NSMakeRange(end, 0), with:"\n")
        content.append(content2)
        
        return content
        
    }
    
    
}






import UIKit

class StringDrawer : UIView {
    @NSCopying var attributedText : NSAttributedString! {
        didSet {
            self.setNeedsDisplay()
        }
    }
    
    override func draw(_ rect: CGRect) {
        let r = rect.offsetBy(dx: 0, dy: 2)
        // just proving it's now an Option Set
        let opts : NSStringDrawingOptions = [.truncatesLastVisibleLine, .usesLineFragmentOrigin]
        
        let context = NSStringDrawingContext()
        context.minimumScaleFactor = 0.5 // does nothing
        
        self.attributedText.draw(with:r, options: opts, context: context)
        
        print(context.totalBounds)
    }
}




