










    @objc func doPresent(_ sender: Any?) {
        let pvc = type(of:self).makePresentedViewController()
        self.present(pvc, animated:true)
    }
    
    @objc func doPush(_ sender: Any?) {
        let svc = type(of:self).makeSecondViewController()
        self.navigationController!.pushViewController(svc, animated:true)
    }














import UIKit

class ViewController : UIViewController, SecondViewControllerDelegate {
    

    @IBAction func doPresent(_ sender: Any?) {
        
        // logging to prove these are normally nil
        print(self.presentingViewController as Any)
        print(self.presentedViewController as Any)
        
        let svc = SecondViewController(nibName: nil, bundle: nil)
        svc.data = "This is very important data!"
        svc.delegate = self
        
        var which : Int { return 5 }
        switch which {
        case 1: break // showing that .CoverVertical is the default
        case 2: svc.modalTransitionStyle = .coverVertical
        case 3: svc.modalTransitionStyle = .crossDissolve // wow, this looks like crap
        case 4: svc.modalTransitionStyle = .partialCurl
            // partial curl is not partial in iOS 8/9/10/11; bug?
            // thus, the "click to dismiss" feature makes no sense
            // user taps background and presented vc just dismisses? weird; bug?
        case 5:
            svc.modalTransitionStyle = .flipHorizontal
            self.view.window!.backgroundColor = UIColor.green // prove window shows thru
            // no transition on present, only on dismiss; bug? - ok, fixed
        default: break
        }
        
        print(self.traitCollection)
        
        var which2 : Int { return 4 }
        switch which2 {
        case 1: break // showing that .FullScreen is the default
        case 2: svc.modalPresentationStyle = .fullScreen
        case 3: svc.modalPresentationStyle = .pageSheet
        case 4: svc.modalPresentationStyle = .formSheet
        case 5:
            svc.modalPresentationStyle = .overFullScreen
            svc.view.alpha = 0.5 // just to prove that it's working
        default: break
        }
        
        self.present(svc, animated:true) {
            print(svc.view.gestureRecognizers as Any)
        }
        // self.showViewController(svc, sender:self) // ooops! we're in a nav interface, uses that :)
    }
    
    func accept(data:Any!) {
        // do something with data here
        
        // prove that you received data
        print(data)
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("vc did disappear")
    }
    
    override func dismiss(animated: Bool, completion: (() -> Void)?) {
        print("dismiss!") // prove that this is called by clicking on curl
        super.dismiss(animated:animated, completion:completion)
    }
    
    
}













import UIKit

/* 

Standard architecture for handing info from vc to presented vc...
...and back when presented vc is dismissed

*/

protocol SecondViewControllerDelegate : class {
    func accept(data:Any!)
}

class SecondViewController : UIViewController {
    
    var data : Any?
    
    weak var delegate : SecondViewControllerDelegate?
    
    @IBAction func doDismiss(_ sender: Any?) {
        print("dismiss button")
        // logging to show relationships
        print(self.presentingViewController!)
        print(self.presentingViewController!.presentedViewController as Any)
        let vc = self.delegate as! UIViewController
        print(vc.presentedViewController as Any)
        
        
        // just proving it works
        // self.dismiss(animated:true)
        // vc.dismiss(animated:true)
        // return;
        
        self.presentingViewController?.dismiss(animated:true)
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        // prove you've got data
        print(self.data as Any)
        // also explore size class situation
        print(self.traitCollection)
        
        // workaround for curl bug
        if let grs = self.view.gestureRecognizers {
            for g in grs {
                if NSStringFromClass(type(of:g)).hasSuffix("CurlUpTapGestureRecognizer") {
                    g.isEnabled = false
                }
            }
        }
        // print("parent", self.parent as Any)
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        if self.isBeingDismissed {
            self.delegate?.accept(data:"Even more important data!")
        }
    }
    
    override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
        super.viewWillTransition(to: size, with: coordinator)
        print("new size coming: \(size)")
    }
    
    
}



















import UIKit

class ViewController : UIViewController, SecondViewControllerDelegate {
    
    // the segue in the storyboard is drawn directly from the button...
    // so SecondViewController will be instantiated for us...
    // and "presentViewController" will be called for us
    // thus we need another place to configure
    
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if segue.identifier == "present" { // it will be
            let svc = segue.destination as! SecondViewController
            svc.data = "This is very important data!"
            svc.delegate = self
        }
    }
    
    func accept(data:Any!) {
        // do something with data here
        
        // prove that you received data
        print(data)
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        super.viewDidDisappear(animated)
        print("vc did disappear")
    }
    
    override func dismiss(animated: Bool, completion: (() -> Void)!) {
        print("here") // prove that this is called by clicking on curl
        super.dismiss(animated:animated, completion: completion)
    }
    
    
}













import UIKit

/* 

Standard architecture for handing info from vc to presented vc...
...and back when presented vc is dismissed

*/

protocol SecondViewControllerDelegate : class {
    func accept(data:Any!)
}

class SecondViewController : UIViewController {
    
    var data : Any?
    
    weak var delegate : SecondViewControllerDelegate?
    
    
    // could alternatively use an "unwind" segue here
    // I'll show that later
    
    @IBAction func doDismiss(_ sender: Any?) {
        self.presentingViewController?.dismiss(animated:true)
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        // prove you've got data
        print(self.data as Any)
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        if self.isBeingDismissed {
            self.delegate?.accept(data:"Even more important data!")
        }
    }
    
    
}
