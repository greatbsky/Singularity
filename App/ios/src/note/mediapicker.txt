

import UIKit
import MediaPlayer

extension CGRect {
    init(_ x:CGFloat, _ y:CGFloat, _ w:CGFloat, _ h:CGFloat) {
        self.init(x:x, y:y, width:w, height:h)
    }
}
extension CGSize {
    init(_ width:CGFloat, _ height:CGFloat) {
        self.init(width:width, height:height)
    }
}
extension CGPoint {
    init(_ x:CGFloat, _ y:CGFloat) {
        self.init(x:x, y:y)
    }
}
extension CGVector {
    init (_ dx:CGFloat, _ dy:CGFloat) {
        self.init(dx:dx, dy:dy)
    }
}

func checkForMusicLibraryAccess(andThen f:(()->())? = nil) {
    let status = MPMediaLibrary.authorizationStatus()
    switch status {
    case .authorized:
        f?()
    case .notDetermined:
        MPMediaLibrary.requestAuthorization() { status in
            if status == .authorized {
                DispatchQueue.main.async {
                	f?()
				}
            }
        }
    case .restricted:
        // do nothing
        break
    case .denied:
        // do nothing, or beg the user to authorize us in Settings
        break
    }
}

class ViewController: UIViewController {
    
    @IBAction func doGo (_ sender: Any!) {
        self.presentPicker(sender)
    }
    
    func presentPicker (_ sender: Any) {
        checkForMusicLibraryAccess {
            let picker = MPMediaPickerController(mediaTypes:.music)
            picker.showsCloudItems = false
            picker.delegate = self
            picker.allowsPickingMultipleItems = true
            picker.modalPresentationStyle = .popover
            picker.preferredContentSize = CGSize(500,600)
            self.present(picker, animated: true)
            if let pop = picker.popoverPresentationController {
                if let b = sender as? UIBarButtonItem {
                    pop.barButtonItem = b
                }
            }
        }
    }
}

extension ViewController : MPMediaPickerControllerDelegate {
    // must implement these, as there is no automatic dismissal
    
    func mediaPicker(_ mediaPicker: MPMediaPickerController, didPickMediaItems mediaItemCollection: MPMediaItemCollection) {
        print("did pick")
        let player = MPMusicPlayerController.applicationMusicPlayer()
        player.setQueue(with:mediaItemCollection)
        player.play()
        self.dismiss(animated:true)
    }
    
    func mediaPickerDidCancel(_ mediaPicker: MPMediaPickerController) {
        print("cancel")
        self.dismiss(animated:true)
    }

}

extension ViewController : UIBarPositioningDelegate {
    func positionForBar(forBar bar: UIBarPositioning) -> UIBarPosition {
        return .topAttached
    }
}



























    @IBAction func doPick (_ sender: Any!) {
        
        checkForPhotoLibraryAccess {
        
            // horrible
            // let src = UIImagePickerControllerSourceType.savedPhotosAlbum
            let src = UIImagePickerControllerSourceType.photoLibrary
            guard UIImagePickerController.isSourceTypeAvailable(src)
                else { print("alas"); return }
            guard let arr = UIImagePickerController.availableMediaTypes(for:src)
                else { print("no available types"); return }
            let picker = UIImagePickerController()
            picker.sourceType = src
            picker.mediaTypes = [kUTTypeLivePhoto as String, kUTTypeImage as String, kUTTypeMovie as String]
            picker.delegate = self
            
            picker.allowsEditing = false // try true
            
            // this will automatically be fullscreen on phone and pad, looks fine
            // note that for .photoLibrary, iPhone app must permit portrait orientation
            // if we want a popover, on pad, we can do that; just uncomment next line
            picker.modalPresentationStyle = .popover
            self.present(picker, animated: true)
            // ignore:
            if let pop = picker.popoverPresentationController {
                let v = sender as! UIView
                pop.sourceView = v
                pop.sourceRect = v.bounds
            }
            
        }
        
    }


























import UIKit
import Photos

func delay(_ delay:Double, closure:@escaping ()->()) {
    let when = DispatchTime.now() + delay
    DispatchQueue.main.asyncAfter(deadline: when, execute: closure)
}

func checkForPhotoLibraryAccess(andThen f:(()->())? = nil) {
    let status = PHPhotoLibrary.authorizationStatus()
    switch status {
    case .authorized:
        f?()
    case .notDetermined:
        PHPhotoLibrary.requestAuthorization() { status in
            if status == .authorized {
                DispatchQueue.main.async {
                	f?()
				}
            }
        }
    case .restricted:
        // do nothing
        break
    case .denied:
        // do nothing, or beg the user to authorize us in Settings
        break
    }
}


// this no longer works because PHFetchResult is now a generic, so I'm forced to enumerate results "by hand"
// seems unfair that PHFetchResult adopts NSFastEnumeration in Objective-C but can't say for...in in Swift

//extension PHFetchResult : Sequence {
//    public func makeIterator() -> NSFastEnumerationIterator {
//        return NSFastEnumerationIterator(self)
//    }
//}

class ViewController: UIViewController {
    var albums : PHFetchResult<PHAssetCollection>!

    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
    }


    @IBAction func doButton(_ sender: Any) {
        
        checkForPhotoLibraryAccess{
        
            let opts = PHFetchOptions()
            let desc = NSSortDescriptor(key: "startDate", ascending: true)
            opts.sortDescriptors = [desc]
            let result = PHCollectionList.fetchCollectionLists(with:
                .momentList, subtype: .momentListYear, options: opts)
            for ix in 0..<result.count {
                let list = result[ix]
                let f = DateFormatter()
                f.dateFormat = "yyyy"
                print(f.string(from:list.startDate!))
                // return;
                if list.collectionListType == .momentList {
                    let result = PHAssetCollection.fetchMoments(inMomentList:list, options: nil)
                    for ix in 0 ..< result.count {
                        let coll = result[ix]
                        if ix == 0 {
                            print("======= \(result.count) clusters")
                        }
                        f.dateFormat = ("yyyy-MM-dd")
                        print("starting \(f.string(from:coll.startDate!)): " + "\(coll.estimatedAssetCount)")
                    }
                }
                print("\n")
            }
            
        }
    }

    @IBAction func doButton2(_ sender: Any) {
        
        checkForPhotoLibraryAccess {

            let result = PHAssetCollection.fetchAssetCollections(with:
                // let's examine albums synced onto the device from iPhoto
                .album, subtype: .albumSyncedAlbum, options: nil)
            for ix in 0 ..< result.count {
                let album = result[ix]
                print("\(album.localizedTitle): " +
                    "approximately \(album.estimatedAssetCount) photos")
            }
            
        }
    }
    
    @IBAction func doButton3(_ sender: Any) {
        
        checkForPhotoLibraryAccess {

            let alert = UIAlertController(title: "Pick an album:", message: nil, preferredStyle: .actionSheet)
            alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
            let result = PHAssetCollection.fetchAssetCollections(with:
                .album, subtype: .albumSyncedAlbum, options: nil)
            for ix in 0 ..< result.count {
                let album = result[ix]
                alert.addAction(UIAlertAction(title: album.localizedTitle, style: .default) {
                    (_:UIAlertAction!) in
                    let result = PHAsset.fetchAssets(in:album, options: nil)
                    for ix in 0 ..< result.count {
                        let asset = result[ix]
                        print(asset.localIdentifier)
                    }
                })
            }
            self.present(alert, animated: true)
            if let pop = alert.popoverPresentationController {
                if let v = sender as? UIView {
                    pop.sourceView = v
                    pop.sourceRect = v.bounds
                }
            }
            
        }
    }
    
    var newAlbumId : String?
    @IBAction func doButton4(_ sender: Any) {
        
        checkForPhotoLibraryAccess {

            // modification of the library
            // all modifications operate through their own "changeRequest" class
            // so, for example, to create or delete a PHAssetCollection,
            // or to alter what assets it contains,
            // we need a PHAssetCollectionChangeRequest
            // we can use this only inside a PHPhotoLibrary `performChanges` block
            
            var which : Int {return 2}
            
            
            switch which {
            case 1:
                PHPhotoLibrary.shared().performChanges({
                    let t = "TestAlbum"
                    typealias Req = PHAssetCollectionChangeRequest
                    Req.creationRequestForAssetCollection(withTitle:t)
                })

                
            case 2:
                
                var ph : PHObjectPlaceholder?
                PHPhotoLibrary.shared().performChanges({
                    let t = "TestAlbum"
                    typealias Req = PHAssetCollectionChangeRequest
                    let cr = Req.creationRequestForAssetCollection(withTitle:t)
                    ph = cr.placeholderForCreatedAssetCollection
                }) { ok, err in
                    // completion may take some considerable time (asynchronous)
                    print("created TestAlbum: \(ok)")
                    if ok, let ph = ph {
                        print("and its id is \(ph.localIdentifier)")
                        self.newAlbumId = ph.localIdentifier
                    }
                }

                
            default: break
            }
            
            
        }
    }
    
    @IBAction func doButton5(_ sender: Any) {
        
        checkForPhotoLibraryAccess {
            
            PHPhotoLibrary.shared().register(self) // *

            let opts = PHFetchOptions()
            opts.wantsIncrementalChangeDetails = false
            // use this opts to prevent extra PHChange messages
            
            // imagine first that we are displaying a list of all regular albums...
            // ... so have performed a fetch request and are hanging on to the result
            let alb = PHAssetCollection.fetchAssetCollections(with:
                .album, subtype: .albumRegular, options: nil)
            self.albums = alb
            
            // find Recently Added smart album
            let result = PHAssetCollection.fetchAssetCollections(with:
                .smartAlbum, subtype: .smartAlbumRecentlyAdded, options: opts)
            guard let rec = result.firstObject else {
                print("no recently added album")
                return
            }
            // find its first asset
            let result2 = PHAsset.fetchAssets(in:rec, options: opts)
            guard let asset1 = result2.firstObject else {
                print("no first item in recently added album")
                return
            }
            // find our newly created album by its local id
            let result3 = PHAssetCollection.fetchAssetCollections(
                withLocalIdentifiers: [self.newAlbumId!], options: opts)
            guard let alb2 = result3.firstObject else {
                print("no target album")
                return
            }
            
            PHPhotoLibrary.shared().performChanges({
                typealias Req = PHAssetCollectionChangeRequest
                let cr = Req(for: alb2)
                cr?.addAssets([asset1] as NSArray)
                }, completionHandler: {
                    // completion may take some considerable time (asynchronous)
                    (ok:Bool, err:Error?) in
                    print("added it: \(ok)")
            })
            
        }
    }
}

extension ViewController : PHPhotoLibraryChangeObserver {
    func photoLibraryDidChange(_ changeInfo: PHChange) {
        if self.albums !== nil {
            let details = changeInfo.changeDetails(for:self.albums)
            print(details as Any)
            if details !== nil {
                self.albums = details!.fetchResultAfterChanges
                // ... and adjust interface if needed ...
            }
        }
    }
}
















import UIKit
import Photos
import AVKit

func checkForPhotoLibraryAccess(andThen f:(()->())? = nil) {
    let status = PHPhotoLibrary.authorizationStatus()
    switch status {
    case .authorized:
        f?()
    case .notDetermined:
        PHPhotoLibrary.requestAuthorization() { status in
            if status == .authorized {
                DispatchQueue.main.async {
                    f?()
                }
            }
        }
    case .restricted:
        // do nothing
        break
    case .denied:
        // do nothing, or beg the user to authorize us in Settings
        break
    }
}

class ViewController: UIViewController {
    @IBOutlet weak var v: UIView!

    @IBAction func doShowMovie(_ sender: Any) {
        checkForPhotoLibraryAccess(andThen: self.reallyShowMovie)
    }
    
    func reallyShowMovie() {
        let opts = PHFetchOptions()
        opts.fetchLimit = 1
        let result = PHAsset.fetchAssets(with: .video, options: opts)
        guard result.count > 0 else {return}
        let asset = result[0]
        PHImageManager.default().requestPlayerItem(forVideo: asset, options: nil) {
            item, info in
            print(item as Any)
            if let item = item {
                DispatchQueue.main.async {
                    self.display(item:item)
                }
            }
        }
    }
    
    func display(item:AVPlayerItem) {
        let player = AVPlayer(playerItem: item)
        let vc = AVPlayerViewController()
        vc.player = player
        vc.view.frame = self.v.bounds
        self.addChildViewController(vc)
        self.v.addSubview(vc.view)
        vc.didMove(toParentViewController: self)
    }

}





