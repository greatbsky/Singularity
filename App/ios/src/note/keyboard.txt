




import UIKit

class ViewController: UIViewController {
    @IBOutlet var textFields : [UITextField]!
    var fr: UIResponder!
    var accessoryView : UIView!
    

    override func viewDidLoad() {
        super.viewDidLoad()
        // configure accessory view
        let arr = UINib(nibName:"AccessoryView", bundle:nil).instantiate(withOwner:nil)
        self.accessoryView = arr[0] as! UIView
        let b = self.accessoryView.subviews[0] as! UIButton
        b.addTarget(self, action:#selector(doNextButton), for:.touchUpInside)
        // new iOS 10 feature, just testing
        // didn't behave well, not documenting
//        for tf in self.textFields {
//            tf.textContentType = .emailAddress
//        }
    }
    


    func textFieldDidBeginEditing(_ tf: UITextField) {
        self.fr = tf // keep track of first responder
        tf.inputAccessoryView = self.accessoryView
        tf.keyboardAppearance = .dark
        
        
    }

    func textFieldShouldReturn(_ tf: UITextField) -> Bool {
        self.fr = nil
        tf.resignFirstResponder()
        return true
    }
    
    func doNextButton(_ sender: Any) {
        var ix = self.textFields.index(of:self.fr as! UITextField)!
        ix = (ix + 1) % self.textFields.count
        let v = self.textFields[ix]
        v.becomeFirstResponder()
    }
    
    
}









import UIKit

func lend<T> (closure:(T)->()) -> T where T:NSObject {
    let orig = T()
    closure(orig)
    return orig
}

class ViewController: UIViewController, UITextViewDelegate {
    @IBOutlet var tv : UITextView!
    var keyboardShowing = false

    override func viewDidLoad() {
        super.viewDidLoad()

        let path = Bundle.main.path(forResource: "brillig", ofType: "txt")!
        let s = try! String(contentsOfFile:path)
        let s2 = s.replacingOccurrences(of:"\n", with: "")
        let mas = NSMutableAttributedString(string:s2, attributes:[
            NSFontAttributeName: UIFont(name:"GillSans", size:20)!
            ])
        
        mas.addAttribute(NSParagraphStyleAttributeName,
            value:lend(){
                (para:NSMutableParagraphStyle) in
                para.alignment = .left
                para.lineBreakMode = .byWordWrapping
            },
            range:NSMakeRange(0,1))
        
        self.tv.attributedText = mas

        NotificationCenter.default.addObserver(self, selector: #selector(keyboardShow), name: .UIKeyboardWillShow, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(keyboardHide), name: .UIKeyboardWillHide, object: nil)
        
        self.tv.keyboardDismissMode = .interactive

    }
    
    override var shouldAutorotate : Bool {
        return !self.keyboardShowing
    }
    
    // as long as you play your part (adjust content offset),
    // iOS 8 will play its part (scroll cursor to visible)
    // and we don't have to animate
    
    func keyboardShow(_ n:Notification) {
        if self.keyboardShowing {
            return
        }
        self.keyboardShowing = true

        
        print("show")
        
        let d = n.userInfo!
        var r = d[UIKeyboardFrameEndUserInfoKey] as! CGRect
        r = self.tv.convert(r, from:nil)
        self.tv.contentInset.bottom = r.size.height
        self.tv.scrollIndicatorInsets.bottom = r.size.height
        
        

    }
    
    func keyboardHide(_ n:Notification) {
        if !self.keyboardShowing {
            return
        }
        self.keyboardShowing = false

        print("hide")
        
        self.tv.contentInset = .zero
        self.tv.scrollIndicatorInsets = .zero
        

    }

    func doDone(_ sender: Any) {
        self.view.endEditing(false)
    }

}











