



    func setUpChildSimple() {
        let url = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
        let player = AVPlayer(url:url)
        let av = AVPlayerViewController()
        av.player = player
        av.view.frame = CGRect(10,10,300,200)
        self.addChildViewController(av)
        self.view.addSubview(av.view)
        av.didMove(toParentViewController:self)
    }
    









class ViewController: UIViewController {
    
    override var prefersStatusBarHidden : Bool {
        return true
    }

//    override var supportedInterfaceOrientations : UIInterfaceOrientationMask {
//        if UIDevice.currentDevice().userInterfaceIdiom == .Pad {
//            return UIInterfaceOrientationMask.All
//        }
//        return UIInterfaceOrientationMask.Landscape
//    }
    

    let which = 1
    
    @IBAction func go() {
        switch which {
        case 1:
            let url = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
            let asset = AVURLAsset(url:url)
            let item = AVPlayerItem(asset:asset)
            let player = AVPlayer(playerItem:item)
            let av = AVPlayerViewController()
            av.view.frame = CGRect(10,10,300,200)
            av.player = player
            self.addChildViewController(av)
            self.view.addSubview(av.view)
            av.didMove(toParentViewController: self)
        case 2:
            self.setUpChild()
        default: break
        }
    }
    
    func setUpChild() {
        let url = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
        let asset = AVURLAsset(url:url)
        let track = #keyPath(AVURLAsset.tracks)
        asset.loadValuesAsynchronously(forKeys:[track]) {
            let status = asset.statusOfValue(forKey:track, error: nil)
            if status == .loaded {
                DispatchQueue.main.async {
                    self.getVideoTrack(asset)
                }
            }
        }
    }
    
    func getVideoTrack(_ asset:AVAsset) {
        // we have tracks or we wouldn't be here
        let visual = AVMediaCharacteristicVisual
        let vtrack = asset.tracks(withMediaCharacteristic: visual)[0]
        let size = #keyPath(AVAssetTrack.naturalSize)
        vtrack.loadValuesAsynchronously(forKeys: [size]) {
            let status = vtrack.statusOfValue(forKey: size, error: nil)
            if status == .loaded {
                DispatchQueue.main.async {
                    self.getNaturalSize(vtrack, asset)
                }
            }
        }
    }
    
    func getNaturalSize(_ vtrack:AVAssetTrack, _ asset:AVAsset) {
        // we have a natural size or we wouldn't be here
        let sz = vtrack.naturalSize
        let item = AVPlayerItem(asset:asset)
        let player = AVPlayer(playerItem:item)
        let av = AVPlayerViewController()
        av.view.frame = AVMakeRect(aspectRatio: sz, insideRect: CGRect(10,10,300,200))
        av.player = player
        self.addChildViewController(av)
        av.view.isHidden = true
        self.view.addSubview(av.view)
        av.didMove(toParentViewController: self)
        av.addObserver(
            self, forKeyPath: #keyPath(AVPlayerViewController.readyForDisplay), options: .new, context: nil)
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
            let ready = #keyPath(AVPlayerViewController.readyForDisplay)
            guard keyPath == ready else {return}
            guard let vc = object as? AVPlayerViewController else {return}
            guard let ok = change?[.newKey] as? Bool else {return}
            guard ok else {return}
            vc.removeObserver(self, forKeyPath:ready)
            DispatchQueue.main.async {
                vc.view.isHidden = false
            }
    }

    



}



















import UIKit
import AVFoundation
import AVKit

extension CGRect {
    init(_ x:CGFloat, _ y:CGFloat, _ w:CGFloat, _ h:CGFloat) {
        self.init(x:x, y:y, width:w, height:h)
    }
}
extension CGSize {
    init(_ width:CGFloat, _ height:CGFloat) {
        self.init(width:width, height:height)
    }
}
extension CGPoint {
    init(_ x:CGFloat, _ y:CGFloat) {
        self.init(x:x, y:y)
    }
}
extension CGVector {
    init (_ dx:CGFloat, _ dy:CGFloat) {
        self.init(dx:dx, dy:dy)
    }
}



class ViewController: UIViewController {
    @IBOutlet var player : AVPlayer!
    @IBOutlet var playerLayer : AVPlayerLayer!
    var pic : AVPictureInPictureController!
    
    @IBOutlet weak var picButton: UIButton!
    
    let which = 2
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        switch which {
        case 1:
            let m = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
            //        let p = AVPlayer(URL:m)!
            let asset = AVURLAsset(url:m)
            let item = AVPlayerItem(asset:asset)
            let p = AVPlayer(playerItem:item)
            self.player = p // might need a reference later
            let lay = AVPlayerLayer(player:p)
            lay.frame = CGRect(10,10,300,200)
            self.playerLayer = lay // might need a reference later
            // self.view.layer.addSublayer(lay)
        case 2:
            let m = Bundle.main.url(forResource:"ElMirage", withExtension:"mp4")!
            let asset = AVURLAsset(url:m)
            let item = AVPlayerItem(asset:asset)
            let p = AVPlayer() // *
            self.player = p
            let lay = AVPlayerLayer(player:p)
            lay.frame = CGRect(10,10,300,200)
            self.playerLayer = lay
            p.replaceCurrentItem(with: item) // *
            // self.view.layer.addSublayer(lay)
        default:break
        }
        

        
        if AVPictureInPictureController.isPictureInPictureSupported() {
            let pic = AVPictureInPictureController(playerLayer: self.playerLayer)
            self.pic = pic
        } else {
            self.picButton.isHidden = true
        }
        
        self.playerLayer.addObserver(self, forKeyPath:#keyPath(AVPlayerLayer.readyForDisplay), context:nil)
        
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == #keyPath(AVPlayerLayer.readyForDisplay) {
            DispatchQueue.main.async {
                self.finishConstructingInterface()
            }
        }
    }
    
    func finishConstructingInterface () {
        if (!self.playerLayer.isReadyForDisplay) {
            return
        }
        
        self.playerLayer.removeObserver(self, forKeyPath:#keyPath(AVPlayerLayer.readyForDisplay))
        
        if self.playerLayer.superlayer == nil {
            self.view.layer.addSublayer(self.playerLayer)
        }
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        try? AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)
        try? AVAudioSession.sharedInstance().setActive(true)
    }

    
    @IBAction func doButton (_ sender: Any!) {
        let rate = self.player.rate
        self.player.rate = rate < 0.01 ? 1 : 0
    }

    
    @IBAction func restart (_ sender: Any!) {
        let item = self.player.currentItem! //
        item.seek(to:CMTime(seconds:0, preferredTimescale:600))
    }

    @IBAction func doPicInPic(_ sender: Any) {
        if self.pic.isPictureInPicturePossible {
            self.pic.startPictureInPicture()
        }
    }

    
}

extension ViewController : AVPictureInPictureControllerDelegate {
    
    // this is the nuttiest bit of renamification!
    func picture(_ pictureInPictureController: AVPictureInPictureController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler completionHandler: @ escaping (Bool) -> Void) {
        
    }

}














import UIKit
import AVKit
import AVFoundation

class ViewController: UIViewController {
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        try? AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)
        try? AVAudioSession.sharedInstance().setActive(true)
        
        // sheesh
        self.navigationController?.hidesBarsOnSwipe = true
        self.navigationController?.barHideOnTapGestureRecognizer.isEnabled = false
    }


    let which = 1
    
    @IBAction func doPresent(_ sender: Any) {
        switch which {
        case 1:
            let av = AVPlayerViewController()
            let url = Bundle.main.url(forResource:"ElMirage", withExtension: "mp4")!
            // let url = Bundle.main.url(forResource:"wilhelm", withExtension: "aiff")!
            let player = AVPlayer(url: url)
            av.player = player
            self.present(av, animated: true) {
                // av.view.backgroundColor = .green
            }
//            let iv = UIImageView(image:UIImage(named:"smiley")!)
//            av.contentOverlayView!.addSubview(iv)
//            let v = iv.superview!
//            iv.translatesAutoresizingMaskIntoConstraints = false
//            NSLayoutConstraint.activate([
//                iv.bottomAnchor.constraint(equalTo:v.bottomAnchor),
//                iv.topAnchor.constraint(equalTo:v.topAnchor),
//                iv.leadingAnchor.constraint(equalTo:v.leadingAnchor),
//                iv.trailingAnchor.constraint(equalTo:v.trailingAnchor),
//                ])

            av.delegate = self
            av.allowsPictureInPicturePlayback = true
            av.updatesNowPlayingInfoCenter = false // what does this do?
        case 2:
            // hmmm... this works so poorly that I can't really recommend it
            // if edgesForExtendedLayout is not set, we see the position slider just peeping down;
            // if it is, we don't see it at all, and so important functionality is lost
            // moreover, no matter what I do, the resulting interface is very confusing for the user
            // so I'm going to cut discussion of this approach from the book
            let av = AVPlayerViewController()
            av.edgesForExtendedLayout = []
            self.navigationController?.navigationBar.isTranslucent = false
//            let url = Bundle.main.url(forResource:"ElMirage", withExtension: "mp4")!
             let url = Bundle.main.url(forResource:"wilhelm", withExtension: "aiff")!
            let player = AVPlayer(url: url)
            av.player = player
            av.view.backgroundColor = .green
            self.show(av, sender: self)
        default: break
        }
        
    }
}

extension ViewController : AVPlayerViewControllerDelegate {
    
//    func playerViewControllerShouldAutomaticallyDismissAtPictureInPictureStart(_ playerViewController: AVPlayerViewController) -> Bool {
//        return false
//    }
    
    
    func playerViewController(_ pvc: AVPlayerViewController, restoreUserInterfaceForPictureInPictureStopWithCompletionHandler ch: @escaping (Bool) -> Void) {
        self.present(pvc, animated:true) { 
            ch(true)
        }
    }

}
















